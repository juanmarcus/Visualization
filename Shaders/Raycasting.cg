// Metaball functions

//wyvill constants
const float a = -0.444444;
const float b = 1.888889;
const float c = -2.444444;

uniform sampler1D metaballs_tex;

uniform int num_metaballs;
uniform float4 Metaballs[10];

float4 Wyvill6v(float3 Pos, float3 Center, float radius)
{
	float radius2 = radius * radius;
	float3 dist = Pos - Center;
	float dist2 = dot(dist, dist);
	if (dist2 > radius2)
		return 0;
	float dist4 = dist2 * dist2;
	float dist6 = dist4 * dist2;
	float radius4 = radius2 * radius2;
	float radius6 = radius4 * radius2;

	float r = (a * dist6 / radius6) + (b * dist4 / radius4) + (c * dist2
			/ radius2) + 1;
	return float4(normalize(dist), r);
}

float Wyvill6t(float3 Pos, float3 Center, float radius)
{
	float3 dist = Pos - Center;
	float l = length(dist);
	if (l >= radius) {
		return 0;
	}
	float4 a = tex1D(metaballs_tex,l*(1/radius));

	return a.a;
}

// Transformations

float3 WarpVector(float3 p, float3 v, float3 c)
{
	return p - normalize(v) * dot(v, p - c);
}

// Define interface between the application and the vertex program
struct app_vertex
{
	float4 Position :POSITION;
	float4 TexCoord :TEXCOORD1;
	float4 Color :COLOR0;
};

// Define the interface between the vertex- and the fragment programs
struct vertex_fragment
{
	float4 Position :POSITION; // For the rasterizer
	float4 TexCoord :TEXCOORD0;
	float4 Color :TEXCOORD1;
	float4 Pos :TEXCOORD2;
};

struct fragment_out
{
	float4 Color :COLOR0;
};

// Raycasting vertex program implementation
vertex_fragment vertex_main(app_vertex IN)
{
	vertex_fragment OUT;

	// Get OpenGL state matrices
	//float4x4 ModelView = glstate.matrix.modelview[0];
	float4x4 ModelViewProj = glstate.matrix.mvp;

	// Transform vertex
	OUT.Position = mul(ModelViewProj, IN.Position);
	OUT.Pos = mul(ModelViewProj, IN.Position);
	OUT.TexCoord = IN.TexCoord;
	OUT.Color = IN.Color;
	return OUT;
}

// Raycasting fragment program implementation
fragment_out fragment_main( vertex_fragment IN,
		uniform sampler2D tex,
		uniform float stepsize)
{
	fragment_out OUT;
	float2 texc = ((IN.Pos.xy / IN.Pos.w) + 1.0) / 2.0; // find the right place to lookup in the backside buffer
	float4 start = IN.TexCoord; // the start position of the ray is stored in the texturecoordinate
	float4 back_position = tex2D(tex, texc);
	float3 dir = back_position.xyz - start.xyz;
	float len = length(dir.xyz); // the length from front to back is calculated and used to terminate the ray
	float3 norm_dir = normalize(dir);
	float delta = stepsize;
	float3 delta_dir = norm_dir * delta;
	float delta_dir_len = length(delta_dir);
	float3 vec = start;
	float length_acc = 0.0;

	float3 desl = float3(0.5, 0.5, 0.5);

	for(int i = 0; i < 450; i++)
	{
//		float3 dist = vec - (ball + desl);
//		float l = length(dist);
//		OUT.Color = float4(0.0,0.0,l,1.0);
//		return OUT;
//		float4 a = tex1D(metaballs_tex,l*(1/0.1));
//		OUT.Color = float4(0.0,0.0,a.a,1.0);
//		OUT.Color = float4(0.0,0.0,length(vec - ball + desl)/10,1.0);
//		return OUT;
//		float4 field;
//		field.w = a.a;
//		= a.a;
		float field = 0.0;
		for (int i=0; i< num_metaballs; ++i) {
			float3 dball = Metaballs[i].xyz + desl;
			float3 wvec = WarpVector(vec,float3(1.0,1.0,1.0),dball);
//			field += Wyvill6v(wvec, dball, Metaballs[i].w).w;
			field += Wyvill6t(wvec, dball, Metaballs[i].w);
		}
		//loop de metaballs aqui
//		float4 field = Wyvill6v(, ball + desl, 1.0);
//		field += Wyvill6v(WarpVector(vec,float3(1.0,1.0,1.0),ball2 + desl), ball2 + desl, 0.1);
//		field += Wyvill6v(WarpVector(vec,float3(1.0,1.0,1.0),ball3 + desl), ball3 + desl, 0.1);
//		field += Wyvill6v(WarpVector(vec,float3(1.0,1.0,1.0),ball4 + desl), ball4 + desl, 0.1);
//		field += Wyvill6v(WarpVector(vec,float3(1.0,1.0,1.0),ball5 + desl), ball5 + desl, 0.1);
//		field += Wyvill6v(WarpVector(vec,float3(1.0,1.0,1.0),ball6 + desl), ball6 + desl, 0.1);
		if (field < 0.52 && field> 0.48)
		{
			OUT.Color = float4(0.0,0.7,0.2,1.0)	;
			return OUT;
		}
//		if (field > 0.52) {
//			break;
//		}
		vec += delta_dir;
		length_acc += delta_dir_len;
		if (length_acc >= len)
		{
			break; // terminate if opacity > 1 or the ray is outside the volume
		}
	}

	OUT.Color = float4(0.0,0.0,0.0,0.0);;
	return OUT;
}
